<!DOCTYPE html>
<html lang="ko">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Timetable Generator & Editor (Dual Mode)</title>
    <style>
        /* ==================== 1. Editor UI Styles ==================== */
        :root {
            --bg-color: #1e272e;
            --panel-bg: #2d3436;
            --text-color: #f5f6fa;
            --accent-color: #0984e3;
            --border-color: rgba(255,255,255,0.1);
        }

        * {
            box-sizing: border-box;
            margin: 0;
            padding: 0;
            font-family: 'Pretendard', sans-serif;
        }

        body {
            background-color: var(--bg-color);
            color: var(--text-color);
            width: 100vw;
            height: 100vh;
            display: flex;
            overflow: hidden;
        }

        /* --- Left Control Panel --- */
        aside {
            width: 320px;
            background: var(--panel-bg);
            border-right: 1px solid var(--border-color);
            display: flex;
            flex-direction: column;
            padding: 20px;
            z-index: 100;
            box-shadow: 2px 0 10px rgba(0,0,0,0.3);
            overflow-y: auto;
        }

            aside h2 {
                font-size: 1.1rem;
                margin-bottom: 15px;
                color: var(--accent-color);
            }

        .control-group {
            margin-bottom: 20px;
            border-bottom: 1px solid var(--border-color);
            padding-bottom: 15px;
        }

            .control-group label {
                display: block;
                margin-bottom: 6px;
                font-size: 0.8rem;
                color: #b2bec3;
            }

        input[type="file"], input[type="text"], input[type="number"] {
            width: 100%;
            padding: 8px;
            background: #1e272e;
            border: 1px solid #636e72;
            color: white;
            border-radius: 4px;
            font-size: 0.85rem;
            margin-bottom: 8px;
        }

        .btn {
            width: 100%;
            padding: 10px;
            border: none;
            border-radius: 4px;
            background: var(--accent-color);
            color: white;
            font-weight: bold;
            cursor: pointer;
            transition: background 0.2s;
            margin-top: 5px;
            font-size: 0.85rem;
        }

            .btn:hover {
                background: #74b9ff;
            }

        .btn-success {
            background: #00b894;
        }

            .btn-success:hover {
                background: #55efc4;
            }

        .btn-toggle {
            background: #e17055;
            margin-bottom: 10px;
        }

            .btn-toggle:hover {
                background: #ff7675;
            }

        .input-row {
            display: flex;
            gap: 10px;
            margin-bottom: 5px;
        }

        .input-wrap {
            flex: 1;
        }

        /* --- Right Preview Stage --- */
        main {
            flex: 1;
            display: flex;
            flex-direction: column;
            position: relative;
            overflow: hidden;
        }

        .header {
            height: 50px;
            display: flex;
            align-items: center;
            justify-content: space-between;
            padding: 0 20px;
            border-bottom: 1px solid var(--border-color);
            flex-shrink: 0;
        }

        .mode-indicator {
            font-size: 0.8rem;
            font-weight: bold;
            padding: 4px 8px;
            border-radius: 4px;
            background: #636e72;
        }

        /* Scrollable Container for PX mode */
        .stage-container {
            flex: 1;
            position: relative;
            display: flex;
            overflow: auto;
        }

        /* --- Timetable Grid --- */
        .time-col {
            width: 60px;
            flex-shrink: 0;
            border-right: 1px solid var(--border-color);
            background: #222f3e;
            position: sticky;
            left: 0;
            z-index: 50;
        }
        /* Grid Canvas:
           % Mode: width 100%, height 100%
           Px Mode: width/height calculated by JS
        */
        .grid-canvas {
            flex: 1;
            position: relative;
            min-width: 100%;
            min-height: 100%;
        }

        .time-label {
            position: absolute;
            right: 5px;
            font-size: 0.75rem;
            color: #b2bec3;
            transform: translateY(-50%);
        }

        .room-headers {
            display: flex;
            height: 40px;
            border-bottom: 1px solid var(--border-color);
            position: absolute;
            top: 0;
            width: 100%;
            left: 0;
            background: #2d3436;
            z-index: 40;
        }

        .room-header {
            flex: 1;
            display: flex;
            align-items: center;
            justify-content: center;
            border-right: 1px solid var(--border-color);
            font-size: 0.85rem;
            font-weight: bold;
        }

        .grid-lines {
            position: absolute;
            top: 40px;
            bottom: 0;
            left: 0;
            right: 0;
            pointer-events: none;
        }

        .h-line {
            position: absolute;
            left: 0;
            right: 0;
            border-top: 1px dashed rgba(255,255,255,0.05);
        }

        .v-line {
            position: absolute;
            top: 0;
            bottom: 0;
            border-right: 1px solid rgba(255,255,255,0.05);
        }

        .card-layer {
            position: absolute;
            top: 40px;
            bottom: 0;
            left: 0;
            right: 0;
        }

        .class-card {
            position: absolute;
            border-radius: 4px;
            padding: 4px;
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            text-align: center;
            color: white;
            font-size: 0.75rem;
            cursor: pointer;
            overflow: hidden;
            box-shadow: 0 2px 5px rgba(0,0,0,0.3);
            border: 2px solid transparent;
            transition: transform 0.1s;
        }

            .class-card.selected {
                border-color: #ffeaa7;
                z-index: 1000 !important;
                box-shadow: 0 0 15px rgba(255, 234, 167, 0.5);
                transform: scale(1.02);
            }

        /* Categories */
        .cat-art-adv {
            background: #d63031;
        }

        .cat-prog-adv {
            background: #0984e3;
        }

        .cat-plan-adv {
            background: #f1c40f;
            color: #2d3436;
        }

        .cat-graphic {
            background: #6c5ce7;
        }

        .cat-webtoon {
            background: #e17055;
        }

        .cat-kdigital {
            background: #d35400;
        }

        .cat-default {
            background: #636e72;
        }
    </style>
</head>
<body>

    <aside>
        <h2>⚙️ Editor Control</h2>

        <div class="control-group">
            <label>Mode Setting</label>
            <button class="btn btn-toggle" id="btnToggleMode">Switch to Pixel (px) Mode</button>
            <p style="font-size:0.75rem; color:#b2bec3;">* Pixel mode allows scrollbars.</p>
        </div>

        <div class="control-group">
            <label>1. Load JSON Data</label>
            <input type="file" id="jsonFileInput" accept=".json, .js">
        </div>

        <div class="control-group">
            <label>2. Edit Selected Card</label>
            <div id="selectedCardInfo" style="margin-bottom:10px; font-size:0.9rem; color:#dfe6e9; min-height:20px;">No card selected</div>

            <label style="color:#74b9ff; margin-top:10px;">• Layout (<span id="unitLabel">%</span>)</label>
            <div class="input-row">
                <div class="input-wrap"><input type="number" id="inpLeft" placeholder="X"></div>
                <div class="input-wrap"><input type="number" id="inpTop" placeholder="Y"></div>
            </div>
            <div class="input-row">
                <div class="input-wrap"><input type="number" id="inpWidth" placeholder="W"></div>
                <div class="input-wrap"><input type="number" id="inpHeight" placeholder="H"></div>
            </div>

            <label style="color:#74b9ff; margin-top:10px;">• Custom Text</label>
            <input type="text" id="inpSubject" placeholder="Override Subject">
            <input type="text" id="inpInstructor" placeholder="Override Instructor">
        </div>

        <div class="control-group" style="border:none;">
            <label>3. Export</label>
            <button class="btn btn-success" id="btnDownload">Download Viewer (.html)</button>
        </div>
    </aside>

    <main>
        <div class="header">
            <h3>Preview Stage</h3>
            <div class="mode-indicator" id="modeIndicator">Mode: Percent (%)</div>
        </div>
        <div class="stage-container" id="stageContainer">
            <div class="time-col" id="viewTimeCol"></div>
            <div class="grid-canvas" id="gridCanvas">
                <div class="room-headers" id="viewHeaders"></div>
                <div class="grid-lines" id="viewGridLines"></div>
                <div class="card-layer" id="viewCardLayer"></div>
            </div>
        </div>
    </main>

    <script>
        /**
         * =======================================================
         * [MODEL] Data & State
         * =======================================================
         */

        class ClassDTO {
            constructor(data) {
                this.id = data.id || Date.now();
                this.subject = data.subject;
                this.instructor = data.instructor;
                this.room = data.room;
                this.days = data.days;
                this.category = data.category || 'default';
                this.startH = parseInt(data.startH);
                this.endH = parseInt(data.endH);
            }
        }

        class ViewDTO {
            constructor(rect, coreData, mergedDays) {
                this.rect = rect; // {x, y, w, h} (Unit depends on mode)
                this.core = coreData;
                this.defaultText = { days: mergedDays };
                // 개별 텍스트 수정을 위한 필드
                this.customText = {
                    subject: '',
                    instructor: ''
                };
            }
        }

        class AppModel {
            constructor() {
                this.rawDTOs = [];
                this.viewDTOs = [];
                this.rooms = [];
                this.config = { start: 9, end: 22 };

                // Mode State
                this.mode = 'percent'; // 'percent' | 'pixel'

                // Pixel Mode Constants (Reference for conversion)
                this.pxSettings = {
                    colWidth: 150,  // 1 강의장 당 너비
                    hourHeight: 60  // 1 시간 당 높이
                };

                // Listeners
                this.onDataLoaded = null;
                this.onViewUpdated = null;
                this.onModeChanged = null;
            }

            loadData(jsonData) {
                this.rawDTOs = jsonData.map(d => new ClassDTO(d));
                this.rooms = [...new Set(this.rawDTOs.map(d => d.room))].sort();

                // 초기 로드는 항상 % 모드로 계산 (기본값)
                this.mode = 'percent';
                this._calculateInitialPercentLayout();

                if (this.onDataLoaded) this.onDataLoaded();
            }

            // 모드 전환 로직 (핵심)
            toggleMode() {
                const prevMode = this.mode;
                this.mode = (prevMode === 'percent') ? 'pixel' : 'percent';

                // 좌표 변환 수행
                this._convertCoordinates(prevMode, this.mode);

                if (this.onModeChanged) this.onModeChanged(this.mode);
                if (this.onViewUpdated) this.onViewUpdated();
            }

            // 좌표 변환: 기존 편집된 위치를 최대한 보존하며 단위 변경
            _convertCoordinates(from, to) {
                // 변환 기준 치수 계산
                const totalHours = this.config.end - this.config.start;
                const totalHeightPx = totalHours * this.pxSettings.hourHeight;
                const totalWidthPx = this.rooms.length * this.pxSettings.colWidth;

                this.viewDTOs.forEach(dto => {
                    if (from === 'percent' && to === 'pixel') {
                        // % -> px
                        dto.rect.x = (dto.rect.x / 100) * totalWidthPx;
                        dto.rect.y = (dto.rect.y / 100) * totalHeightPx;
                        dto.rect.w = (dto.rect.w / 100) * totalWidthPx;
                        dto.rect.h = (dto.rect.h / 100) * totalHeightPx;
                    } else if (from === 'pixel' && to === 'percent') {
                        // px -> %
                        dto.rect.x = (dto.rect.x / totalWidthPx) * 100;
                        dto.rect.y = (dto.rect.y / totalHeightPx) * 100;
                        dto.rect.w = (dto.rect.w / totalWidthPx) * 100;
                        dto.rect.h = (dto.rect.h / totalHeightPx) * 100;
                    }
                });
            }

            // 초기 자동 배치 (% 기준)
            _calculateInitialPercentLayout() {
                this.viewDTOs = [];
                const totalH = this.config.end - this.config.start;
                const colW = 100 / this.rooms.length;

                const grouped = this._groupItems();

                grouped.forEach(group => {
                    const item = group.items[0];
                    const roomIdx = this.rooms.indexOf(item.room);

                    const x = roomIdx * colW;
                    const y = ((item.startH - this.config.start) / totalH) * 100;
                    const w = colW;
                    const h = ((item.endH - item.startH) / totalH) * 100;

                    const days = this._mergeDays(group.items);
                    this.viewDTOs.push(new ViewDTO({ x, y, w, h }, item, days));
                });
            }

            updateCardRect(dto, newRect) {
                dto.rect = { ...newRect };
                if (this.onViewUpdated) this.onViewUpdated();
            }

            updateCardText(dto, type, value) {
                dto.customText[type] = value;
                if (this.onViewUpdated) this.onViewUpdated();
            }

            // Helpers
            _groupItems() {
                const map = new Map();
                this.rawDTOs.forEach(d => {
                    const key = `${d.subject}_${d.instructor}_${d.startH}_${d.room}`;
                    if (!map.has(key)) map.set(key, { items: [] });
                    map.get(key).items.push(d);
                });
                return Array.from(map.values());
            }
            _mergeDays(items) {
                const daysSet = new Set(items.map(i => i.days));
                const hasMWF = [...daysSet].some(d => d.includes('월') && d.includes('수'));
                const hasTT = [...daysSet].some(d => d.includes('화') && d.includes('목'));
                if (hasMWF && hasTT) return "월~금 (매일)";
                return [...daysSet].join(", ");
            }

            // Px 모드일 때 캔버스 전체 크기 계산
            getCanvasDimensions() {
                if (this.mode === 'percent') return { w: '100%', h: '100%' };
                return {
                    w: (this.rooms.length * this.pxSettings.colWidth) + 'px',
                    h: ((this.config.end - this.config.start) * this.pxSettings.hourHeight) + 'px'
                };
            }
        }

        /**
         * =======================================================
         * [VIEW] Editor UI
         * =======================================================
         */
        class EditorView {
            constructor() {
                this.els = {
                    timeCol: document.getElementById('viewTimeCol'),
                    headers: document.getElementById('viewHeaders'),
                    gridLines: document.getElementById('viewGridLines'),
                    cardLayer: document.getElementById('viewCardLayer'),
                    gridCanvas: document.getElementById('gridCanvas'),

                    // Inputs
                    inpLeft: document.getElementById('inpLeft'),
                    inpTop: document.getElementById('inpTop'),
                    inpWidth: document.getElementById('inpWidth'),
                    inpHeight: document.getElementById('inpHeight'),

                    inpSubject: document.getElementById('inpSubject'),
                    inpInstructor: document.getElementById('inpInstructor'),

                    info: document.getElementById('selectedCardInfo'),
                    unitLabel: document.getElementById('unitLabel'),
                    modeIndicator: document.getElementById('modeIndicator'),
                    btnToggle: document.getElementById('btnToggleMode')
                };
                this.selectedCardEl = null;
            }

            updateModeUI(mode) {
                const isPx = mode === 'pixel';
                this.els.unitLabel.textContent = isPx ? 'px' : '%';
                this.els.modeIndicator.textContent = isPx ? 'Mode: Pixel (px)' : 'Mode: Percent (%)';
                this.els.btnToggle.textContent = isPx ? 'Switch to Percent (%) Mode' : 'Switch to Pixel (px) Mode';

                // Input Step 조정
                const inputs = [this.els.inpLeft, this.els.inpTop, this.els.inpWidth, this.els.inpHeight];
                inputs.forEach(inp => inp.step = isPx ? 1 : 0.1);
            }

            renderStage(model) {
                const config = model.config;
                const rooms = model.rooms;
                const dim = model.getCanvasDimensions();

                // 캔버스 크기 조정
                this.els.gridCanvas.style.width = dim.w;
                this.els.gridCanvas.style.height = dim.h;
                this.els.cardLayer.style.height = dim.h; // 중요: 높이 동기화

                // Clear
                this.els.timeCol.innerHTML = '';
                this.els.headers.innerHTML = '';
                this.els.gridLines.innerHTML = '';

                // Grid Rendering
                const isPx = model.mode === 'pixel';
                const totalH = config.end - config.start;

                // 1. Time Column
                for (let h = config.start; h <= config.end; h++) {
                    // Position 계산: Px모드면 픽셀값, 아니면 %값
                    let posVal = isPx
                        ? (h - config.start) * model.pxSettings.hourHeight + "px"
                        : ((h - config.start) / totalH) * 100 + "%";

                    const lbl = document.createElement('div');
                    lbl.className = 'time-label';
                    lbl.textContent = `${h}:00`;
                    lbl.style.top = posVal;
                    this.els.timeCol.appendChild(lbl);

                    if (h !== config.end) {
                        const line = document.createElement('div');
                        line.className = 'h-line';
                        line.style.top = posVal;
                        this.els.gridLines.appendChild(line);
                    }
                }

                // 2. Room Headers
                rooms.forEach((room, i) => {
                    const hd = document.createElement('div');
                    hd.className = 'room-header';
                    hd.textContent = room;
                    this.els.headers.appendChild(hd);

                    if (i > 0) {
                        const vl = document.createElement('div');
                        vl.className = 'v-line';
                        // Position 계산
                        let leftVal = isPx
                            ? i * model.pxSettings.colWidth + "px"
                            : (i / rooms.length) * 100 + "%";

                        vl.style.left = leftVal;
                        this.els.gridLines.appendChild(vl);
                    }
                });
            }

            renderCards(model, onCardClick) {
                this.els.cardLayer.innerHTML = '';
                const unit = model.mode === 'pixel' ? 'px' : '%';

                model.viewDTOs.forEach(dto => {
                    const el = document.createElement('div');
                    el.className = `class-card cat-${dto.core.category}`;

                    el.style.left = dto.rect.x + unit;
                    el.style.top = dto.rect.y + unit;
                    el.style.width = dto.rect.w + unit;
                    el.style.height = dto.rect.h + unit;

                    // 텍스트 표시 우선순위: Custom -> Default
                    const subject = dto.customText.subject || dto.core.subject;
                    const instructor = dto.customText.instructor || dto.core.instructor;

                    el.innerHTML = `
                            <div style="font-weight:800; margin-bottom:2px;">${subject}</div>
                            <div style="opacity:0.9;">${instructor}</div>
                            <div style="font-size:0.7rem; margin-top:2px;">${dto.defaultText.days}</div>
                        `;

                    el.onclick = (e) => {
                        e.stopPropagation();
                        this._selectCard(el, dto);
                        onCardClick(dto);
                    };

                    this.els.cardLayer.appendChild(el);
                });
            }

            _selectCard(el, dto) {
                if (this.selectedCardEl) this.selectedCardEl.classList.remove('selected');
                el.classList.add('selected');
                this.selectedCardEl = el;

                this.els.info.innerHTML = `Selected: <b>${dto.core.subject}</b>`;

                // 좌표 바인딩
                this.els.inpLeft.value = parseFloat(dto.rect.x.toFixed(2));
                this.els.inpTop.value = parseFloat(dto.rect.y.toFixed(2));
                this.els.inpWidth.value = parseFloat(dto.rect.w.toFixed(2));
                this.els.inpHeight.value = parseFloat(dto.rect.h.toFixed(2));

                // 텍스트 바인딩
                this.els.inpSubject.value = dto.customText.subject || ''; // 비어있으면 원본 안보여주고 공란 (override 의도)
                this.els.inpSubject.placeholder = dto.core.subject; // placeholder로 원본 표시
                this.els.inpInstructor.value = dto.customText.instructor || '';
                this.els.inpInstructor.placeholder = dto.core.instructor;
            }
        }

        /**
         * =======================================================
         * [CONTROLLER] Logic
         * =======================================================
         */
        class Controller {
            constructor(model, view) {
                this.model = model;
                this.view = view;
                this.currentSelectedDTO = null;
                this._initEvents();
            }

            _initEvents() {
                // 1. Data Load
                document.getElementById('jsonFileInput').addEventListener('change', (e) => {
                    const file = e.target.files[0];
                    if (!file) return;
                    const reader = new FileReader();
                    reader.onload = (evt) => {
                        try {
                            let content = evt.target.result;
                            if (content.includes('=')) content = content.split('=')[1];
                            if (content.trim().endsWith(';')) content = content.trim().slice(0, -1);
                            this.model.loadData(JSON.parse(content));
                        } catch (err) { alert("Parsing Error"); }
                    };
                    reader.readAsText(file);
                });

                // 2. Mode Toggle
                document.getElementById('btnToggleMode').addEventListener('click', () => {
                    this.model.toggleMode();
                });

                // 3. Model Listeners
                this.model.onDataLoaded = () => this._refreshAll();
                this.model.onModeChanged = (mode) => {
                    this.view.updateModeUI(mode);
                    this._refreshAll(); // 모드 바뀌면 그리드 다시 그려야 함
                };
                this.model.onViewUpdated = () => {
                    this.view.renderCards(this.model, (dto) => {
                        this.currentSelectedDTO = dto;
                        // 선택 상태 유지 로직은 복잡해지므로 생략, 다시 클릭 필요
                    });
                };

                // 4. Input Bindings (Coordinates)
                ['inpLeft', 'inpTop', 'inpWidth', 'inpHeight'].forEach(id => {
                    document.getElementById(id).addEventListener('input', (e) => {
                        if (!this.currentSelectedDTO) return;
                        const val = parseFloat(e.target.value);
                        if (isNaN(val)) return;

                        const rect = { ...this.currentSelectedDTO.rect };
                        if (id === 'inpLeft') rect.x = val;
                        if (id === 'inpTop') rect.y = val;
                        if (id === 'inpWidth') rect.w = val;
                        if (id === 'inpHeight') rect.h = val;

                        // UI 즉시 반영 (Performance)
                        if (this.view.selectedCardEl) {
                            const unit = this.model.mode === 'pixel' ? 'px' : '%';
                            if (id === 'inpLeft') this.view.selectedCardEl.style.left = val + unit;
                            if (id === 'inpTop') this.view.selectedCardEl.style.top = val + unit;
                            if (id === 'inpWidth') this.view.selectedCardEl.style.width = val + unit;
                            if (id === 'inpHeight') this.view.selectedCardEl.style.height = val + unit;
                        }
                        // Data Update
                        this.currentSelectedDTO.rect = rect;
                    });
                });

                // 5. Input Bindings (Text)
                document.getElementById('inpSubject').addEventListener('input', (e) => {
                    if (!this.currentSelectedDTO) return;
                    this.model.updateCardText(this.currentSelectedDTO, 'subject', e.target.value);
                });
                document.getElementById('inpInstructor').addEventListener('input', (e) => {
                    if (!this.currentSelectedDTO) return;
                    this.model.updateCardText(this.currentSelectedDTO, 'instructor', e.target.value);
                });

                // 6. Download
                document.getElementById('btnDownload').addEventListener('click', () => this._downloadHTML());
            }

            _refreshAll() {
                this.view.renderStage(this.model);
                this.view.renderCards(this.model, (dto) => this.currentSelectedDTO = dto);
            }

            _downloadHTML() {
                if (this.model.viewDTOs.length === 0) { alert("No data"); return; }

                const exportData = JSON.stringify(this.model.viewDTOs);
                const roomsData = JSON.stringify(this.model.rooms);
                const mode = this.model.mode; // 'percent' or 'pixel'

                // 템플릿 생성 시 현재 모드 정보 주입
                const htmlContent = this._generateHTMLTemplate(exportData, roomsData, mode);

                const blob = new Blob([htmlContent], { type: 'text/html' });
                const url = URL.createObjectURL(blob);
                const a = document.createElement('a');
                a.href = url;
                a.download = 'timetableVeiw.html';
                document.body.appendChild(a);
                a.click();
                document.body.removeChild(a);
            }

            _generateHTMLTemplate(dataJson, roomsJson, mode) {
                const isPx = mode === 'pixel';
                const unit = isPx ? 'px' : '%';
                // Px모드일 경우 뷰어에서도 스크롤이 필요하므로 CSS 조정
                const containerStyle = isPx ? 'overflow: auto;' : 'overflow: hidden;';
                const canvasStyle = isPx
                    ? `width: ${this.model.getCanvasDimensions().w}; height: ${this.model.getCanvasDimensions().h};`
                    : 'width: 100%; height: 100%;';

                return `<!DOCTYPE html>
<html lang="ko">
<head>
        <meta charset="UTF-8">
        <meta name="viewport" content="width=device-width, initial-scale=1.0">
        <title>Timetable Viewer (${mode})</title>
        <style>
            * { box-sizing: border-box; margin: 0; padding: 0; font-family: 'Pretendard', sans-serif; }
            body { background-color: #1e272e; color: #f5f6fa; width: 100vw; height: 100vh; display: flex; flex-direction: column; }
            .header { height: 60px; display: flex; align-items: center; justify-content: center; background: #2d3436; flex-shrink: 0; }
            .header h1 { font-size: 1.5rem; color: #74b9ff; }

            .stage-wrap { flex: 1; position: relative; display: flex; ${containerStyle} }
            .time-col { width: 60px; background: #222f3e; border-right: 1px solid rgba(255,255,255,0.1); position: sticky; left: 0; z-index: 50; flex-shrink: 0; }

            /* Dynamic Canvas Size */
            .grid-canvas { position: relative; ${canvasStyle} }

            .time-label { position: absolute; right: 5px; font-size: 0.75rem; color: #b2bec3; transform: translateY(-50%); }
            .room-headers { display: flex; height: 40px; border-bottom: 1px solid rgba(255,255,255,0.1); position: absolute; top: 0; width: 100%; background: #2d3436; z-index: 40; }
            .room-header { flex: 1; display: flex; align-items: center; justify-content: center; border-right: 1px solid rgba(255,255,255,0.1); font-weight: bold; font-size: 0.9rem; }
            .grid-lines { position: absolute; top: 40px; bottom: 0; left: 0; right: 0; pointer-events: none; }
            .h-line { position: absolute; left: 0; right: 0; border-top: 1px dashed rgba(255,255,255,0.05); }
            .v-line { position: absolute; top: 0; bottom: 0; border-right: 1px solid rgba(255,255,255,0.05); }

            .class-card {
                position: absolute; border-radius: 6px; padding: 5px;
                display: flex; flex-direction: column; align-items: center; justify-content: center;
                text-align: center; color: white; font-size: 0.8rem;
                box-shadow: 0 4px 6px rgba(0,0,0,0.3); overflow: hidden;
                transition: transform 0.2s; cursor: pointer;
            }
            .class-card:hover { transform: scale(1.05); z-index: 100; box-shadow: 0 10px 20px rgba(0,0,0,0.5); }

            /* Categories */
            .cat-art-adv { background: #d63031; } .cat-prog-adv { background: #0984e3; }
            .cat-plan-adv { background: #f1c40f; color: #2d3436; } .cat-graphic { background: #6c5ce7; }
            .cat-webtoon { background: #e17055; } .cat-kdigital { background: #d35400; }
            .cat-default { background: #636e72; }
        </style>
</head>
<body>
        <div class="header"><h1>ACADEMY TIMETABLE</h1></div>
        <div class="stage-wrap">
            <div class="time-col" id="tCol"></div>
            <div class="grid-canvas">
                <div class="room-headers" id="rHead"></div>
                <div class="grid-lines" id="gLine"></div>
                <div id="cLayer"></div>
            </div>
        </div>
        <script>
            const DATA = ${dataJson};
            const ROOMS = ${roomsJson};
            const CONFIG = { start: 9, end: 22 };
            const UNIT = '${unit}';
            const IS_PX = ${isPx};

            // Px모드용 설정 (뷰어 렌더링용)
            const PX_SET = { colW: 150, hourH: 60 };

            document.addEventListener('DOMContentLoaded', () => {
                const tCol = document.getElementById('tCol');
                const rHead = document.getElementById('rHead');
                const gLine = document.getElementById('gLine');
                const cLayer = document.getElementById('cLayer');
                const totalH = CONFIG.end - CONFIG.start;

                // 1. Grid Render
                for(let h=CONFIG.start; h<=CONFIG.end; h++) {
                    let pos = IS_PX
                        ? (h - CONFIG.start) * PX_SET.hourH + 'px'
                        : ((h - CONFIG.start) / totalH) * 100 + '%';

                    const l = document.createElement('div'); l.className='time-label'; l.innerText = h+":00"; l.style.top=pos; tCol.appendChild(l);
                    if(h !== CONFIG.end){
                        const hl = document.createElement('div'); hl.className='h-line'; hl.style.top=pos; gLine.appendChild(hl);
                    }
                }
                ROOMS.forEach((r, i) => {
                    const rh = document.createElement('div'); rh.className='room-header'; rh.innerText=r; rHead.appendChild(rh);
                    if(i>0) {
                        const vl = document.createElement('div'); vl.className='v-line';
                        let left = IS_PX ? i * PX_SET.colW + 'px' : (i/ROOMS.length)*100 + '%';
                        vl.style.left=left; gLine.appendChild(vl);
                    }
                });

                // 2. Card Render
                DATA.forEach(dto => {
                    const el = document.createElement('div');
                    el.className = 'class-card cat-' + dto.core.category;
                    el.style.left = dto.rect.x + UNIT;
                    el.style.top = dto.rect.y + UNIT;
                    el.style.width = dto.rect.w + UNIT;
                    el.style.height = dto.rect.h + UNIT;

                    // Custom Text Logic
                    const subject = dto.customText.subject || dto.core.subject;
                    const instructor = dto.customText.instructor || dto.core.instructor;

                    el.innerHTML = "<b>" + subject + "</b><br><span style='font-size:0.9em; opacity:0.8'>" + instructor + "</span><br><span style='font-size:0.8em'>" + dto.defaultText.days + "</span>";
                    cLayer.appendChild(el);
                });
            });
        <\/script>
</body>
</html>`;
            }
        }

        const appModel = new AppModel();
        const appView = new EditorView();
        const appController = new Controller(appModel, appView);

    </script>
</body>
</html>