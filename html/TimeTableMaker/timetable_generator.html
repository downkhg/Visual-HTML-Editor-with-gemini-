<!DOCTYPE html>
<html lang="ko">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Timetable Editor (Drag Select)</title>
    <style>
        /* ==================== CORE UI Styles ==================== */
        :root {
            --bg-color: #1e272e;
            --panel-bg: #2d3436;
            --text-color: #f5f6fa;
            --accent-color: #0984e3;
            --border-color: rgba(255,255,255,0.1);
        }

        * {
            box-sizing: border-box;
            margin: 0;
            padding: 0;
            font-family: 'Pretendard', sans-serif;
            user-select: none; /* ÎìúÎûòÍ∑∏ Ïãú ÌÖçÏä§Ìä∏ ÏÑ†ÌÉù Î∞©ÏßÄ */
        }

        body {
            background-color: var(--bg-color);
            color: var(--text-color);
            width: 100vw;
            height: 100vh;
            display: flex;
            overflow: hidden;
        }

        /* Left Panel */
        aside {
            width: 340px;
            background: var(--panel-bg);
            border-right: 1px solid var(--border-color);
            display: flex;
            flex-direction: column;
            padding: 20px;
            z-index: 100;
            box-shadow: 2px 0 10px rgba(0,0,0,0.3);
            overflow-y: auto;
        }

            aside h2 {
                font-size: 1.1rem;
                margin-bottom: 15px;
                color: var(--accent-color);
            }

        .control-group {
            margin-bottom: 20px;
            border-bottom: 1px solid var(--border-color);
            padding-bottom: 15px;
        }

            .control-group label {
                display: block;
                margin-bottom: 6px;
                font-size: 0.8rem;
                color: #b2bec3;
            }

        input[type="file"], input[type="text"], input[type="number"], select {
            width: 100%;
            padding: 8px;
            background: #1e272e;
            border: 1px solid #636e72;
            color: white;
            border-radius: 4px;
            font-size: 0.85rem;
            margin-bottom: 8px;
        }

        input:disabled {
            background: #2d3436;
            border-color: #4b4b4b;
            color: #636e72;
            cursor: not-allowed;
        }

        .btn {
            width: 100%;
            padding: 10px;
            border: none;
            border-radius: 4px;
            background: var(--accent-color);
            color: white;
            font-weight: bold;
            cursor: pointer;
            transition: background 0.2s;
            margin-top: 5px;
            font-size: 0.85rem;
        }

            .btn:hover {
                background: #74b9ff;
            }

        .btn-success {
            background: #00b894;
        }

            .btn-success:hover {
                background: #55efc4;
            }

        .btn-toggle {
            background: #e17055;
            margin-bottom: 10px;
        }

            .btn-toggle:hover {
                background: #ff7675;
            }

        .input-row {
            display: flex;
            gap: 10px;
            margin-bottom: 5px;
        }

        .input-wrap {
            flex: 1;
        }

        .sm-label {
            font-size: 0.7rem;
            color: #dfe6e9;
            margin-bottom: 2px;
            display: block;
        }

        /* Right Stage */
        main {
            flex: 1;
            display: flex;
            flex-direction: column;
            position: relative;
            overflow: hidden;
        }

        .header {
            height: 50px;
            display: flex;
            align-items: center;
            justify-content: space-between;
            padding: 0 20px;
            border-bottom: 1px solid var(--border-color);
            flex-shrink: 0;
        }

        .mode-indicator {
            font-size: 0.8rem;
            font-weight: bold;
            padding: 4px 8px;
            border-radius: 4px;
            background: #636e72;
        }

        .stage-container {
            flex: 1;
            position: relative;
            display: flex;
            overflow: auto;
        }

        .time-col {
            width: 60px;
            flex-shrink: 0;
            border-right: 1px solid var(--border-color);
            background: #222f3e;
            position: sticky;
            left: 0;
            z-index: 50;
        }

        .grid-canvas {
            flex: 1;
            position: relative;
            min-width: 100%;
            min-height: 100%;
        }

        .time-label {
            position: absolute;
            right: 5px;
            font-size: 0.75rem;
            color: #b2bec3;
            transform: translateY(-50%);
        }

        .room-headers {
            display: flex;
            height: 40px;
            border-bottom: 1px solid var(--border-color);
            position: absolute;
            top: 0;
            width: 100%;
            left: 0;
            background: #2d3436;
            z-index: 40;
        }

        .room-header {
            flex: 1;
            display: flex;
            align-items: center;
            justify-content: center;
            border-right: 1px solid var(--border-color);
            font-size: 0.85rem;
            font-weight: bold;
        }

        .grid-lines {
            position: absolute;
            top: 40px;
            bottom: 0;
            left: 0;
            right: 0;
            pointer-events: none;
        }

        .h-line {
            position: absolute;
            left: 0;
            right: 0;
            border-top: 1px dashed rgba(255,255,255,0.05);
        }

        .v-line {
            position: absolute;
            top: 0;
            bottom: 0;
            border-right: 1px solid rgba(255,255,255,0.05);
        }

        .card-layer {
            position: absolute;
            top: 40px;
            bottom: 0;
            left: 0;
            right: 0;
            z-index: 60;
        }

        /* Selection Box (Drag Area) */
        .selection-box {
            position: absolute;
            background: rgba(9, 132, 227, 0.2);
            border: 1px solid #74b9ff;
            display: none;
            z-index: 9999;
            pointer-events: none; /* Ï§ëÏöî: ÎßàÏö∞Ïä§ Ïù¥Î≤§Ìä∏Í∞Ä ÏïÑÎûò Ï∫îÎ≤ÑÏä§Î°ú ÌÜµÍ≥ºÎêòÎèÑÎ°ù Ìï® */
        }

        /* ==================== CARD STYLING (Default Theme Integrated) ==================== */
        .class-card {
            position: absolute;
            cursor: pointer;
            overflow: hidden;
            display: flex;
            flex-direction: column;
            align-items: flex-start;
            justify-content: space-between;
            padding: 10px;
            border-radius: 12px;
            color: white;
            box-shadow: 0 4px 15px rgba(0,0,0,0.2);
            border: 1px solid rgba(255,255,255,0.1);
            transition: transform 0.2s;
        }

            .class-card:hover {
                z-index: 1000 !important;
            }

            .class-card.selected {
                z-index: 1000 !important;
                transform: scale(1.02);
                outline: 3px solid #ffeaa7;
                box-shadow: 0 0 20px rgba(0,0,0,0.5);
            }

        .instructor-highlight {
            background: rgba(255, 255, 255, 0.25);
            backdrop-filter: blur(4px);
            border: 1px solid rgba(255, 255, 255, 0.5);
            border-radius: 20px;
            padding: 4px 12px;
            font-weight: 700;
            margin-bottom: 6px;
            box-shadow: 0 2px 5px rgba(0,0,0,0.1);
            align-self: flex-start;
        }

        .day-badge {
            background: transparent;
            border: 1px solid rgba(255,255,255,0.3);
            border-radius: 6px;
            padding: 2px 6px;
            opacity: 0.9;
        }

        /* ==================== üé® CATEGORY & DIFFICULTY THEME ==================== */
        /* [ÏÉâÏÉÅ Í∑úÏπô]
        - ÌîÑÎ°úÍ∑∏ÎûòÎ∞ç (Blue): ÎÖºÎ¶¨, Íµ¨Ï°∞
        - Í∏∞Ìöç (Yellow): ÏïÑÏù¥ÎîîÏñ¥, Íµ¨ÏÑ±
        - ÏïÑÌä∏ (Red): ÏãúÍ∞Å, ÌëúÌòÑ
    
        [ÌòºÌï© Í∑úÏπô]
        - ÏõπÌà∞ (Art + Plan): Red + Yellow = Orange (Art Ïö∞ÏÑ∏)
        - ÏõπÏÜåÏÑ§ (Plan + Art): Yellow + Red = Amber/Gold (Plan Ïö∞ÏÑ∏)
        - Í∑∏ÎûòÌîΩ (Art + Prog): Red + Blue = Purple
    
        [ÎÇúÏù¥ÎèÑÎ≥Ñ Î™ÖÎèÑ Í∑úÏπô]
        - Í∏∞Ï¥à (Basic): Î™ÖÎèÑ ÎÜíÏùå (ÌååÏä§ÌÖîÌÜ§, Î∞ùÏùå) -> Í∏ÄÏûêÏÉâ Ïñ¥ÎëêÏõÄ(#2d3436)
        - Ïã¨Ìôî (Adv): Î™ÖÎèÑ ÎÇÆÏùå (ÎπÑÎπÑÎìú/Îî•ÌÜ§, Ïñ¥ÎëêÏõÄ) -> Í∏ÄÏûêÏÉâ Î∞ùÏùå(#ffffff)
        */

        /* 1. Programming (Blue Í≥ÑÏó¥) */
        /* Í∏∞Ï¥à: C#, Í∏∞Ï¥à Î¨∏Î≤ï Îì± */
        .cat-programming {
            background: #74b9ff; /* Light Blue (Î∞ùÏùÄ ÌååÎûë) */
            color: #2d3436;
        }
        /* Ïã¨Ìôî: ÌÅ¥ÎùºÏù¥Ïñ∏Ìä∏, ÏóîÏßÑ Ïã¨Ìôî, Ìè¨Ìä∏Ìè¥Î¶¨Ïò§ */
        .cat-prog-adv {
            background: #0984e3; /* Vivid Blue (ÍπäÏùÄ ÌååÎûë) */
            color: #ffffff;
        }

        /* 2. Planning (Yellow Í≥ÑÏó¥) */
        /* Í∏∞Ï¥à (Í∞ÄÏ†ï): Í∏∞Ìöç Í∞úÎ°† Îì± (ÌòÑÏû¨ Îç∞Ïù¥ÌÑ∞ ÏóÜÏùå, ÏòàÎπÑÏö©) */
        .cat-plan-basic {
            background: #ffeaa7; /* Pale Yellow (Ïó∞Ìïú ÎÖ∏Îûë) */
            color: #2d3436;
        }
        /* Ïã¨Ìôî: ÏãúÏä§ÌÖú Í∏∞Ìöç, Ïó≠Í∏∞Ìöç */
        .cat-plan-adv {
            background: #f39c12; /* Orange Yellow (ÏßÑÌïú Í∞úÎÇòÎ¶¨ÏÉâ - Í∞ÄÎèÖÏÑ± ÏúÑÌï¥ ÏïΩÍ∞Ñ Ïñ¥Îë°Í≤å Ï°∞Ï†ï) */
            color: #ffffff; /* Î∞∞Í≤ΩÏù¥ ÏßÑÌï¥Ï°åÏúºÎØÄÎ°ú Í∏ÄÏûêÎäî Ìù∞ÏÉâ Ï∂îÏ≤ú, ÏõêÎ≥µ ÏõêÌïòÏãúÎ©¥ #2d3436 */
        }

        /* 3. Art (Red Í≥ÑÏó¥) */
        /* Í∏∞Ï¥à: ÎìúÎ°úÏûâ Í∏∞Ï¥à, Ïù∏Ï≤¥ Ìï¥Î∂ÄÌïô */
        .cat-art-basic {
            background: #ff7675; /* Soft Red/Pink (Ïó∞Ìïú Îπ®Í∞ï) */
            color: #2d3436;
        }
        /* Ïã¨Ìôî: Ïª®ÏÖâ ÏïÑÌä∏, ÏùºÎü¨Ïä§Ìä∏ */
        .cat-art-adv {
            background: #d63031; /* Strong Red (Í∞ïÎ†¨Ìïú Îπ®Í∞ï) */
            color: #ffffff;
        }
        /* UI/Ïù¥Î™®Ìã∞ÏΩò: ÏïÑÌä∏Ïùò ÏÑúÎ∏å Ïπ¥ÌÖåÍ≥†Î¶¨ (Í∞ÄÎ≥çÍ≥† Î∞ùÏùÄ ÎäêÎÇå) */
        .cat-ui, .cat-emo {
            background: #fab1a0; /* Peach (Î≥µÏà≠ÏïÑÏÉâ - ÏïÑÌä∏ Í∏∞Ï¥àÏôÄ Ïú†ÏÇ¨ÌïòÍ±∞ÎÇò Îçî Î∞ùÏùå) */
            color: #2d3436;
        }

        /* 4. Mixed Categories (ÌòºÌï© Í≥ÑÏó¥) */

        /* [Graphic] ÏïÑÌä∏(Red) + ÌîÑÎ°úÍ∑∏ÎûòÎ∞ç(Blue) = Purple */
        /* Í∏∞Ïà†Ï†Å ÏïÑÌä∏(TA), ÏâêÏù¥Îçî, 3D Ìà¥ Îì± */
        .cat-graphic {
            background: #6c5ce7; /* Vivid Purple (Î≥¥ÎùºÏÉâ - ÏöîÏ≤≠ÌïòÏã† Í∑úÏπô Ï†ÅÏö©) */
            color: #ffffff;
        }

        /* [Webtoon] ÏïÑÌä∏(Red) + Í∏∞Ìöç(Yellow) = Orange */
        /* ÏûëÌôî ÏúÑÏ£º, Ïó∞Ï∂ú */
        .cat-webtoon {
            background: #e17055; /* Burnt Orange (ÏßÑÌïú Ï£ºÌô© - ÏïÑÌä∏Ïùò Î∂âÏùÄÍ∏∞ Í∞ïÌï®) */
            color: #ffffff;
        }

        /* [Web Novel] Í∏∞Ìöç(Yellow) + ÏïÑÌä∏(Red) = Amber */
        /* Ïä§ÌÜ†Î¶¨ ÏúÑÏ£º, Î¨òÏÇ¨ */
        .cat-novel {
            background: #fdcb6e; /* Mustard/Amber (Î®∏Ïä§ÌÉÄÎìúÏÉâ - Í∏∞ÌöçÏùò ÎÖ∏ÎûÄÍ∏∞ Í∞ïÌï®) */
            color: #2d3436;
        }

        /* 5. Special / High Difficulty */

        /* [Portfolio] Ï¢ÖÌï© Í≥ºÏ†ï (Î™®Îì† Ïó≠ÎüâÏùò ÏßëÌï©) */
        /* Í∞ÄÏû• ÎÜíÏùÄ Ï±ÑÎèÑÏùò Î≥¥ÎùºÏÉâ ÏÇ¨Ïö© */
        .cat-port {
            background: #8e44ad; /* Deep Violet (ÏßÑÌïú Î≥¥Îùº) */
            color: #ffffff;
        }

        /* [K-Digital/Expert] Íµ≠ÎπÑ/Ï†ÑÎ¨∏Í∞Ä Í≥ºÏ†ï */
        /* ÎÇúÏù¥ÎèÑ ÏµúÏÉÅ -> Î™ÖÎèÑ ÏµúÌïò (Í∞ÄÏû• Î¨¥Í±∞Ïö¥ ÏÉâ) */
        .cat-kdigital {
            background: #b71540; /* Dark Crimson (Í≤ÄÎ∂âÏùÄÏÉâ) */
            color: #ffffff;
            border: 2px solid #ffcccc; /* Íµ≠ÎπÑ Í≥ºÏ†ï Í∞ïÏ°∞Î•º ÏúÑÌïú ÌÖåÎëêÎ¶¨ */
        }

        /* [Default] Î∂ÑÎ•ò ÏóÜÏùå */
        .cat-default {
            background: #636e72; /* Grey */
            color: #ffffff;
        }
    </style>
</head>
<body>

    <aside>
        <h2>‚öôÔ∏è Editor Control</h2>

        <div class="control-group">
            <label>Mode Setting</label>
            <button class="btn btn-toggle" id="btnToggleMode">Switch to Pixel (px) Mode</button>
            <p style="font-size:0.75rem; color:#b2bec3;">* Drag to Multi-select / Ctrl+Click</p>
        </div>

        <div class="control-group">
            <label>1. Load JSON Data</label>
            <input type="file" id="jsonFileInput" accept=".json, .js">
        </div>

        <div class="control-group">
            <label>2. Inspector <span id="selectionCount" style="float:right; color:#fab1a0; font-size:0.75rem;">0 Selected</span></label>

            <label style="color:#74b9ff; margin-top:10px;">‚Ä¢ Layout (<span id="unitLabel">%</span>) <span id="layoutLockMsg" style="font-size:0.7rem; color:#e17055; display:none;">(Locked)</span></label>
            <div class="input-row">
                <div class="input-wrap"><span class="sm-label">X</span><input type="number" id="inpLeft"></div>
                <div class="input-wrap"><span class="sm-label">Y</span><input type="number" id="inpTop"></div>
            </div>
            <div class="input-row">
                <div class="input-wrap"><span class="sm-label">W</span><input type="number" id="inpWidth"></div>
                <div class="input-wrap"><span class="sm-label">H</span><input type="number" id="inpHeight"></div>
            </div>

            <label style="color:#74b9ff; margin-top:10px;">‚Ä¢ Individual Font Sizes (rem)</label>
            <div class="input-row">
                <div class="input-wrap"><span class="sm-label">Subject</span><input type="number" id="inpSubjSize" step="0.05" placeholder="-"></div>
                <div class="input-wrap"><span class="sm-label">Instructor</span><input type="number" id="inpInstSize" step="0.05" placeholder="-"></div>
                <div class="input-wrap"><span class="sm-label">Day</span><input type="number" id="inpDaySize" step="0.05" placeholder="-"></div>
            </div>

            <label style="color:#74b9ff; margin-top:10px;">‚Ä¢ Custom Text</label>
            <input type="text" id="inpSubject" placeholder="Override Subject">
            <input type="text" id="inpInstructor" placeholder="Override Instructor">
        </div>

        <div class="control-group" style="border:none;">
            <label>3. Export</label>
            <button class="btn btn-success" id="btnDownload">Download Viewer (.html)</button>
        </div>
    </aside>

    <main id="mainStage">
        <div class="header">
            <h3>Preview Stage</h3>
            <div class="mode-indicator" id="modeIndicator">Mode: Percent (%)</div>
        </div>
        <div class="stage-container" id="stageContainer">
            <div class="time-col" id="viewTimeCol"></div>
            <div class="grid-canvas" id="gridCanvas">
                <div class="room-headers" id="viewHeaders"></div>
                <div class="grid-lines" id="viewGridLines"></div>
                <div class="card-layer" id="viewCardLayer"></div>
                <div class="selection-box" id="selectionBox"></div>
            </div>
        </div>
    </main>

    <script>
        /**
         * ==================== MODEL ====================
         */
        class ClassDTO {
            constructor(data) {
                this.id = data.id || Date.now();
                this.subject = data.subject; this.instructor = data.instructor;
                this.room = data.room; this.days = data.days;
                this.category = data.category || 'default';
                this.startH = parseInt(data.startH); this.endH = parseInt(data.endH);
            }
        }

        class ViewDTO {
            constructor(rect, coreData, mergedDays) {
                this.rect = rect; this.core = coreData;
                this.defaultText = { days: mergedDays };
                this.customText = { subject: '', instructor: '' };
                this.style = { subjSize: 0.9, instSize: 0.8, daySize: 0.75 };
            }
            get text() {
                return {
                    subject: this.customText.subject || this.core.subject,
                    instructor: this.customText.instructor || this.core.instructor,
                    days: this.defaultText.days
                };
            }
        }

        class AppModel {
            constructor() {
                this.rawDTOs = []; this.viewDTOs = []; this.rooms = [];
                this.config = { start: 9, end: 22 };
                this.mode = 'percent';
                this.pxSettings = { colWidth: 150, hourHeight: 60 };

                this.onDataLoaded = null; this.onViewUpdated = null; this.onModeChanged = null;
            }

            loadData(jsonData) {
                this.rawDTOs = jsonData.map(d => new ClassDTO(d));
                this.rooms = [...new Set(this.rawDTOs.map(d => d.room))].sort();
                this.mode = 'percent';
                this._calculateInitialPercentLayout();
                if (this.onDataLoaded) this.onDataLoaded();
            }

            toggleMode() {
                const prevMode = this.mode;
                this.mode = (prevMode === 'percent') ? 'pixel' : 'percent';
                this._convertCoordinates(prevMode, this.mode);
                if (this.onModeChanged) this.onModeChanged(this.mode);
                if (this.onViewUpdated) this.onViewUpdated();
            }

            _convertCoordinates(from, to) {
                const totalHours = this.config.end - this.config.start;
                const totalHeightPx = totalHours * this.pxSettings.hourHeight;
                const totalWidthPx = this.rooms.length * this.pxSettings.colWidth;
                this.viewDTOs.forEach(dto => {
                    if (from === 'percent' && to === 'pixel') {
                        dto.rect.x = (dto.rect.x / 100) * totalWidthPx; dto.rect.y = (dto.rect.y / 100) * totalHeightPx;
                        dto.rect.w = (dto.rect.w / 100) * totalWidthPx; dto.rect.h = (dto.rect.h / 100) * totalHeightPx;
                    } else if (from === 'pixel' && to === 'percent') {
                        dto.rect.x = (dto.rect.x / totalWidthPx) * 100; dto.rect.y = (dto.rect.y / totalHeightPx) * 100;
                        dto.rect.w = (dto.rect.w / totalWidthPx) * 100; dto.rect.h = (dto.rect.h / totalHeightPx) * 100;
                    }
                });
            }

            _calculateInitialPercentLayout() {
                this.viewDTOs = [];
                const totalH = this.config.end - this.config.start;
                const colW = 100 / this.rooms.length;
                const grouped = this._groupItems();
                grouped.forEach(group => {
                    const item = group.items[0];
                    const roomIdx = this.rooms.indexOf(item.room);
                    const x = roomIdx * colW;
                    const y = ((item.startH - this.config.start) / totalH) * 100;
                    const w = colW;
                    const h = ((item.endH - item.startH) / totalH) * 100;
                    const days = this._mergeDays(group.items);
                    this.viewDTOs.push(new ViewDTO({ x, y, w, h }, item, days));
                });
            }

            _groupItems() {
                const map = new Map();
                this.rawDTOs.forEach(d => {
                    const key = `${d.subject}_${d.instructor}_${d.startH}_${d.room}`;
                    if (!map.has(key)) map.set(key, { items: [] });
                    map.get(key).items.push(d);
                });
                return Array.from(map.values());
            }
            _mergeDays(items) {
                const daysSet = new Set(items.map(i => i.days));
                const hasMWF = [...daysSet].some(d => d.includes('Ïõî') && d.includes('Ïàò'));
                const hasTT = [...daysSet].some(d => d.includes('Ìôî') && d.includes('Î™©'));
                if (hasMWF && hasTT) return "Ïõî~Í∏à";
                return [...daysSet].join(", ");
            }
            getCanvasDimensions() {
                if (this.mode === 'percent') return { w: '100%', h: '100%' };
                return { w: (this.rooms.length * this.pxSettings.colWidth) + 'px', h: ((this.config.end - this.config.start) * this.pxSettings.hourHeight) + 'px' };
            }
        }

        /**
         * ==================== VIEW ====================
         */
        class EditorView {
            constructor() {
                this.els = {
                    timeCol: document.getElementById('viewTimeCol'),
                    headers: document.getElementById('viewHeaders'),
                    gridLines: document.getElementById('viewGridLines'),
                    cardLayer: document.getElementById('viewCardLayer'),
                    gridCanvas: document.getElementById('gridCanvas'),
                    selectionBox: document.getElementById('selectionBox'), // [NEW]

                    inpLeft: document.getElementById('inpLeft'), inpTop: document.getElementById('inpTop'),
                    inpWidth: document.getElementById('inpWidth'), inpHeight: document.getElementById('inpHeight'),

                    inpSubject: document.getElementById('inpSubject'), inpInstructor: document.getElementById('inpInstructor'),
                    inpSubjSize: document.getElementById('inpSubjSize'), inpInstSize: document.getElementById('inpInstSize'), inpDaySize: document.getElementById('inpDaySize'),

                    selectionCount: document.getElementById('selectionCount'),
                    layoutLockMsg: document.getElementById('layoutLockMsg'),
                    unitLabel: document.getElementById('unitLabel'),
                    modeIndicator: document.getElementById('modeIndicator'),
                    btnToggle: document.getElementById('btnToggleMode')
                };
            }

            updateModeUI(mode) {
                const isPx = mode === 'pixel';
                this.els.unitLabel.textContent = isPx ? 'px' : '%';
                this.els.modeIndicator.textContent = isPx ? 'Mode: Pixel (px)' : 'Mode: Percent (%)';
                this.els.btnToggle.textContent = isPx ? 'Switch to Percent (%) Mode' : 'Switch to Pixel (px) Mode';
                [this.els.inpLeft, this.els.inpTop, this.els.inpWidth, this.els.inpHeight].forEach(inp => inp.step = isPx ? 1 : 0.1);
            }

            syncInspector(selectedSet) {
                const count = selectedSet.size;
                this.els.selectionCount.textContent = `${count} Selected`;

                const allInputs = [this.els.inpLeft, this.els.inpTop, this.els.inpWidth, this.els.inpHeight, this.els.inpSubject, this.els.inpInstructor, this.els.inpSubjSize, this.els.inpInstSize, this.els.inpDaySize];

                if (count === 0) {
                    allInputs.forEach(el => { el.value = ''; el.disabled = true; el.placeholder = '-'; });
                    this.els.layoutLockMsg.style.display = 'none';
                    return;
                }
                allInputs.forEach(el => el.disabled = false);

                const list = Array.from(selectedSet);
                if (count > 1) {
                    [this.els.inpLeft, this.els.inpTop, this.els.inpHeight].forEach(el => { el.value = ''; el.disabled = true; el.placeholder = 'Locked'; });
                    this.els.layoutLockMsg.style.display = 'inline';
                    this.els.layoutLockMsg.textContent = '(Pos/H Locked)';
                    this._bindMixedInput(this.els.inpWidth, list, d => parseFloat(d.rect.w.toFixed(2)));
                } else {
                    const dto = list[0];
                    this.els.inpLeft.value = parseFloat(dto.rect.x.toFixed(2));
                    this.els.inpTop.value = parseFloat(dto.rect.y.toFixed(2));
                    this.els.inpWidth.value = parseFloat(dto.rect.w.toFixed(2));
                    this.els.inpHeight.value = parseFloat(dto.rect.h.toFixed(2));
                    this.els.layoutLockMsg.style.display = 'none';
                }

                this._bindMixedInput(this.els.inpSubjSize, list, d => d.style.subjSize);
                this._bindMixedInput(this.els.inpInstSize, list, d => d.style.instSize);
                this._bindMixedInput(this.els.inpDaySize, list, d => d.style.daySize);
                this._bindMixedInput(this.els.inpSubject, list, d => d.customText.subject || '', d => d.core.subject);
                this._bindMixedInput(this.els.inpInstructor, list, d => d.customText.instructor || '', d => d.core.instructor);
            }

            _bindMixedInput(el, list, valueGetter, placeholderGetter = null) {
                const firstVal = valueGetter(list[0]);
                const isAllSame = list.every(d => valueGetter(d) === firstVal);
                if (isAllSame) {
                    el.value = firstVal;
                    if (placeholderGetter) el.placeholder = placeholderGetter(list[0]);
                } else {
                    el.value = '';
                    el.placeholder = 'Mixed';
                }
            }

            renderStage(model) {
                const config = model.config; const rooms = model.rooms; const dim = model.getCanvasDimensions();
                this.els.gridCanvas.style.width = dim.w; this.els.gridCanvas.style.height = dim.h; this.els.cardLayer.style.height = dim.h;
                this.els.timeCol.innerHTML = ''; this.els.headers.innerHTML = ''; this.els.gridLines.innerHTML = '';

                const isPx = model.mode === 'pixel';
                const totalH = config.end - config.start;

                for (let h = config.start; h <= config.end; h++) {
                    let posVal = isPx ? (h - config.start) * model.pxSettings.hourHeight + "px" : ((h - config.start) / totalH) * 100 + "%";
                    const lbl = document.createElement('div'); lbl.className = 'time-label'; lbl.textContent = `${h}:00`; lbl.style.top = posVal; this.els.timeCol.appendChild(lbl);
                    if (h !== config.end) { const line = document.createElement('div'); line.className = 'h-line'; line.style.top = posVal; this.els.gridLines.appendChild(line); }
                }
                rooms.forEach((room, i) => {
                    const hd = document.createElement('div'); hd.className = 'room-header'; hd.textContent = room; this.els.headers.appendChild(hd);
                    if (i > 0) { const vl = document.createElement('div'); vl.className = 'v-line'; let leftVal = isPx ? i * model.pxSettings.colWidth + "px" : (i / rooms.length) * 100 + "%"; vl.style.left = leftVal; this.els.gridLines.appendChild(vl); }
                });
            }

            renderCards(model, selectedSet, onCardClick) {
                this.els.cardLayer.innerHTML = '';
                const unit = model.mode === 'pixel' ? 'px' : '%';

                model.viewDTOs.forEach(dto => {
                    const el = document.createElement('div');
                    el.className = `class-card cat-${dto.core.category}`;
                    if (selectedSet.has(dto)) el.classList.add('selected');

                    el.style.left = dto.rect.x + unit; el.style.top = dto.rect.y + unit;
                    el.style.width = dto.rect.w + unit; el.style.height = dto.rect.h + unit;

                    // Standard (Glass) Layout directly implemented
                    el.innerHTML = `
                            <div style="font-weight:800; font-size:${dto.style.subjSize}rem; margin-bottom:auto; line-height:1.2; text-shadow:0 2px 4px rgba(0,0,0,0.1); word-break:keep-all;">${dto.text.subject}</div>
                            <div class="instructor-highlight" style="font-size:${dto.style.instSize}rem;">${dto.text.instructor}</div>
                            <div class="day-badge" style="font-size:${dto.style.daySize * 0.9}rem;">${dto.text.days}</div>
                        `;

                    el.onclick = (e) => { e.stopPropagation(); onCardClick(dto, e); };
                    // Add attribute for Drag Selection identification
                    el.dataset.id = dto.id; // Assume unique or use index
                    // Actually, we can just match by DTO reference later, but DOM needs mapped back to DTO for drag logic.
                    // Better to just calculate geometry overlap from DTOs directly in controller.

                    this.els.cardLayer.appendChild(el);
                });
            }
        }

        /**
         * ==================== CONTROLLER ====================
         */
        class Controller {
            constructor(model, view) {
                this.model = model; this.view = view;
                this.selectedDTOs = new Set();
                this._initEvents();
                this._initDragSelection(); // [NEW]
            }

            _initEvents() {
                // 0. Stage Click (Background)
                document.getElementById('gridCanvas').addEventListener('click', (e) => {
                    // Only clear if directly clicking background, not via drag end
                    if (!this.isDragSelecting && !e.target.closest('.class-card')) {
                        this.selectedDTOs.clear(); this._refreshSelection();
                    }
                });

                // 1. Data Load
                document.getElementById('jsonFileInput').addEventListener('change', (e) => {
                    const file = e.target.files[0]; if (!file) return;
                    const reader = new FileReader();
                    reader.onload = (evt) => {
                        try {
                            let content = evt.target.result;
                            if (content.includes('=')) content = content.split('=')[1];
                            if (content.trim().endsWith(';')) content = content.trim().slice(0, -1);
                            this.model.loadData(JSON.parse(content)); this.selectedDTOs.clear();
                        } catch (err) { alert("Parsing Error"); }
                    }; reader.readAsText(file);
                });

                // 2. Mode Toggle
                document.getElementById('btnToggleMode').addEventListener('click', () => { this.model.toggleMode(); this._refreshSelection(); });

                this.model.onDataLoaded = () => this._refreshAll();
                this.model.onModeChanged = (mode) => { this.view.updateModeUI(mode); this._refreshAll(); };
                this.model.onViewUpdated = () => { this.view.renderCards(this.model, this.selectedDTOs, (dto, e) => this._handleCardClick(dto, e)); };

                // 3. Layout Inputs (Width allowed for multi)
                ['inpLeft', 'inpTop', 'inpWidth', 'inpHeight'].forEach(id => {
                    document.getElementById(id).addEventListener('input', (e) => {
                        if (id !== 'inpWidth' && this.selectedDTOs.size > 1) return;
                        const val = parseFloat(e.target.value); if (isNaN(val)) return;
                        this.selectedDTOs.forEach(dto => {
                            const rect = { ...dto.rect };
                            if (id === 'inpLeft') rect.x = val; if (id === 'inpTop') rect.y = val;
                            if (id === 'inpWidth') rect.w = val; if (id === 'inpHeight') rect.h = val;
                            dto.rect = rect;
                        });
                        this.model.onViewUpdated();
                    });
                });

                // 4. Batch Edit Inputs
                const bindBatchInput = (id, applyFn) => {
                    document.getElementById(id).addEventListener('input', (e) => {
                        if (this.selectedDTOs.size === 0) return;
                        const val = e.target.value;
                        this.selectedDTOs.forEach(dto => applyFn(dto, val));
                        this.model.onViewUpdated();
                    });
                };
                bindBatchInput('inpSubject', (dto, val) => dto.customText.subject = val);
                bindBatchInput('inpInstructor', (dto, val) => dto.customText.instructor = val);
                bindBatchInput('inpSubjSize', (dto, val) => dto.style.subjSize = parseFloat(val));
                bindBatchInput('inpInstSize', (dto, val) => dto.style.instSize = parseFloat(val));
                bindBatchInput('inpDaySize', (dto, val) => dto.style.daySize = parseFloat(val));

                // 5. Download
                document.getElementById('btnDownload').addEventListener('click', () => this._downloadHTML());
            }

            // [NEW] Drag Selection Logic
            _initDragSelection() {
                const canvas = this.view.els.gridCanvas;
                const selectionBox = this.view.els.selectionBox;
                let startX, startY;
                this.isDragSelecting = false;

                canvas.addEventListener('mousedown', (e) => {
                    // Prevent drag if clicking a card (allow card move later if implemented, or just selection)
                    if (e.target.closest('.class-card')) return;
                    // Only left click
                    if (e.button !== 0) return;

                    this.isDragSelecting = true;
                    // Coordinates relative to the canvas container
                    const rect = canvas.getBoundingClientRect();
                    startX = e.clientX - rect.left + canvas.scrollLeft;
                    startY = e.clientY - rect.top + canvas.scrollTop;

                    // Initial Box
                    selectionBox.style.left = startX + 'px';
                    selectionBox.style.top = startY + 'px';
                    selectionBox.style.width = '0px';
                    selectionBox.style.height = '0px';
                    selectionBox.style.display = 'block';

                    // Clear selection unless Ctrl is pressed
                    if (!e.ctrlKey && !e.metaKey) {
                        this.selectedDTOs.clear();
                        this._refreshSelection();
                    }
                });

                canvas.addEventListener('mousemove', (e) => {
                    if (!this.isDragSelecting) return;

                    const rect = canvas.getBoundingClientRect();
                    const currentX = e.clientX - rect.left + canvas.scrollLeft;
                    const currentY = e.clientY - rect.top + canvas.scrollTop;

                    const width = Math.abs(currentX - startX);
                    const height = Math.abs(currentY - startY);
                    const left = Math.min(currentX, startX);
                    const top = Math.min(currentY, startY);

                    selectionBox.style.width = width + 'px';
                    selectionBox.style.height = height + 'px';
                    selectionBox.style.left = left + 'px';
                    selectionBox.style.top = top + 'px';
                });

                // Listen on document to catch mouseup even if outside canvas
                document.addEventListener('mouseup', (e) => {
                    if (!this.isDragSelecting) return;

                    // Final Selection Logic
                    const sbRect = selectionBox.getBoundingClientRect();

                    // If drag was very small, treat as click (handled by click listener)
                    if (sbRect.width > 5 && sbRect.height > 5) {
                        // Check intersection with all cards
                        // We compare DOM Rects for simplicity and accuracy across modes
                        const cards = this.view.els.cardLayer.children;
                        Array.from(cards).forEach((cardEl, index) => {
                            const cardRect = cardEl.getBoundingClientRect();
                            if (this._checkIntersection(sbRect, cardRect)) {
                                // Find corresponding DTO. Since we render in order, index matches.
                                // Safer to map properly but DTOs order matches viewDTOs array order in renderCards
                                const dto = this.model.viewDTOs[index];
                                if (dto) this.selectedDTOs.add(dto);
                            }
                        });
                        this._refreshSelection();
                    }

                    this.isDragSelecting = false;
                    selectionBox.style.display = 'none';
                });
            }

            _checkIntersection(r1, r2) {
                return !(r2.left > r1.right ||
                    r2.right < r1.left ||
                    r2.top > r1.bottom ||
                    r2.bottom < r1.top);
            }

            _handleCardClick(dto, e) {
                if (e.ctrlKey || e.metaKey) {
                    if (this.selectedDTOs.has(dto)) this.selectedDTOs.delete(dto);
                    else this.selectedDTOs.add(dto);
                } else {
                    this.selectedDTOs.clear(); this.selectedDTOs.add(dto);
                }
                this._refreshSelection();
            }

            _refreshAll() { this.view.renderStage(this.model); this._refreshSelection(); }
            _refreshSelection() { this.view.renderCards(this.model, this.selectedDTOs, (dto, e) => this._handleCardClick(dto, e)); this.view.syncInspector(this.selectedDTOs); }

            _downloadHTML() {
                if (this.model.viewDTOs.length === 0) { alert("No data"); return; }
                const exportData = JSON.stringify(this.model.viewDTOs);
                const roomsData = JSON.stringify(this.model.rooms);
                const htmlContent = this._generateHTMLTemplate(exportData, roomsData, this.model.mode);
                const blob = new Blob([htmlContent], { type: 'text/html' });
                const url = URL.createObjectURL(blob);
                const a = document.createElement('a'); a.href = url; a.download = 'timetableVeiw.html';
                document.body.appendChild(a); a.click(); document.body.removeChild(a);
            }

            _generateHTMLTemplate(dataJson, roomsJson, mode) {
                const isPx = mode === 'pixel';
                const unit = isPx ? 'px' : '%';
                const containerStyle = isPx ? 'overflow: auto;' : 'overflow: hidden;';
                const canvasStyle = isPx ? `width: ${this.model.getCanvasDimensions().w}; height: ${this.model.getCanvasDimensions().h};` : 'width: 100%; height: 100%;';

                return `<!DOCTYPE html>
<html lang="ko">
<head>
            <meta charset="UTF-8">
            <meta name="viewport" content="width=device-width, initial-scale=1.0">
            <title>Timetable Viewer (${mode})</title>
            <style>
                * { box-sizing: border-box; margin: 0; padding: 0; font-family: 'Pretendard', sans-serif; }
                body { background-color: #1e272e; color: #f5f6fa; width: 100vw; height: 100vh; display: flex; flex-direction: column; }
                .header { height: 60px; display: flex; align-items: center; justify-content: center; background: #2d3436; flex-shrink: 0; }
                .header h1 { font-size: 1.5rem; color: #74b9ff; }
                .stage-wrap { flex: 1; position: relative; display: flex; ${containerStyle} }
                .time-col { width: 60px; background: #222f3e; border-right: 1px solid rgba(255,255,255,0.1); position: sticky; left: 0; z-index: 50; flex-shrink: 0; }
                .grid-canvas { position: relative; ${canvasStyle} }
                .time-label { position: absolute; right: 5px; font-size: 0.75rem; color: #b2bec3; transform: translateY(-50%); }
                .room-headers { display: flex; height: 40px; border-bottom: 1px solid rgba(255,255,255,0.1); position: absolute; top: 0; width: 100%; background: #2d3436; z-index: 40; }
                .room-header { flex: 1; display: flex; align-items: center; justify-content: center; border-right: 1px solid rgba(255,255,255,0.1); font-weight: bold; font-size: 0.9rem; }
                .grid-lines { position: absolute; top: 40px; bottom: 0; left: 0; right: 0; pointer-events: none; }
                .h-line { position: absolute; left: 0; right: 0; border-top: 1px dashed rgba(255,255,255,0.05); }
                .v-line { position: absolute; top: 0; bottom: 0; border-right: 1px solid rgba(255,255,255,0.05); }

                /* Core Card Style */
                .class-card {
                    position: absolute; cursor: pointer; overflow: hidden;
                    display: flex; flex-direction: column; align-items: flex-start; justify-content: space-between;
                    padding: 10px; border-radius: 12px; color: white;
                    box-shadow: 0 4px 15px rgba(0,0,0,0.2); border: 1px solid rgba(255,255,255,0.1);
                    transition: transform 0.2s;
                }
                .class-card:hover { transform: scale(1.05); z-index: 100; box-shadow: 0 10px 20px rgba(0,0,0,0.5); }

                .instructor-highlight {
                    background: rgba(255, 255, 255, 0.25); backdrop-filter: blur(4px);
                    border: 1px solid rgba(255, 255, 255, 0.5); border-radius: 20px;
                    padding: 4px 12px; font-weight: 700; margin-bottom: 6px;
                    box-shadow: 0 2px 5px rgba(0,0,0,0.1); align-self: flex-start;
                }
                .day-badge { background: transparent; border: 1px solid rgba(255,255,255,0.3); border-radius: 6px; padding: 2px 6px; opacity: 0.9; }

                .cat-art-adv { background: #d63031; } .cat-prog-adv { background: #0984e3; } .cat-plan-adv { background: #f1c40f; color: #2d3436; }
                .cat-graphic { background: #6c5ce7; } .cat-webtoon { background: #e17055; } .cat-kdigital { background: #d35400; } .cat-default { background: #636e72; }
            </style>
</head>
<body>
            <div class="header"><h1>ACADEMY TIMETABLE</h1></div>
            <div class="stage-wrap">
                <div class="time-col" id="tCol"></div>
                <div class="grid-canvas"><div class="room-headers" id="rHead"></div><div class="grid-lines" id="gLine"></div><div id="cLayer"></div></div>
            </div>
            <script>
                const DATA = ${dataJson}; const ROOMS = ${roomsJson}; const CONFIG = { start: 9, end: 22 }; const UNIT = '${unit}'; const IS_PX = ${isPx}; const PX_SET = { colW: 150, hourH: 60 };
                document.addEventListener('DOMContentLoaded', () => {
                    const tCol = document.getElementById('tCol'); const rHead = document.getElementById('rHead'); const gLine = document.getElementById('gLine'); const cLayer = document.getElementById('cLayer'); const totalH = CONFIG.end - CONFIG.start;
                    for(let h=CONFIG.start; h<=CONFIG.end; h++) {
                        let pos = IS_PX ? (h - CONFIG.start) * PX_SET.hourH + 'px' : ((h - CONFIG.start) / totalH) * 100 + '%';
                        const l = document.createElement('div'); l.className='time-label'; l.innerText = h+":00"; l.style.top=pos; tCol.appendChild(l);
                        if(h !== CONFIG.end){ const hl = document.createElement('div'); hl.className='h-line'; hl.style.top=pos; gLine.appendChild(hl); }
                    }
                    ROOMS.forEach((r, i) => {
                        const rh = document.createElement('div'); rh.className='room-header'; rh.innerText=r; rHead.appendChild(rh);
                        if(i>0) { const vl = document.createElement('div'); vl.className='v-line'; let left = IS_PX ? i * PX_SET.colW + 'px' : (i/ROOMS.length)*100 + '%'; vl.style.left=left; gLine.appendChild(vl); }
                    });

                    DATA.forEach(dto => {
                        const el = document.createElement('div'); el.className = 'class-card cat-' + dto.core.category;
                        el.style.left = dto.rect.x + UNIT; el.style.top = dto.rect.y + UNIT; el.style.width = dto.rect.w + UNIT; el.style.height = dto.rect.h + UNIT;

                        const subj = dto.customText.subject || dto.core.subject;
                        const inst = dto.customText.instructor || dto.core.instructor;
                        el.innerHTML = \`
                            <div style="font-weight:800; font-size:\${dto.style.subjSize}rem; margin-bottom:auto; line-height:1.2; text-shadow:0 2px 4px rgba(0,0,0,0.1); word-break:keep-all;">\${subj}</div>
                            <div class="instructor-highlight" style="font-size:\${dto.style.instSize}rem;">\${inst}</div>
                            <div class="day-badge" style="font-size:\${dto.style.daySize}rem;">\${dto.defaultText.days}</div>
                        \`;

                        cLayer.appendChild(el);
                    });
                });
            <\/script>
</body>
</html>`;
            }
        }

        const appModel = new AppModel();
        const appView = new EditorView();
        const appController = new Controller(appModel, appView);
    </script>
</body>
</html>